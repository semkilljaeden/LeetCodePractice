
什么叫死锁？死锁的必要条件？如何处理死锁问题？

    Deadlock:

    1. target can only be acquire once  --- read 
    2. No willingly give up, hold and wait --- timeout mechanism, conditional variable
    3. cannot forcely acquire
    4. loop condition   --- make the lock acquiring order all the same


乐观锁&悲观锁，乐观锁与悲观锁的实现方式？

    Passive:Mutex, block other people
    Optimistic: CAS, version number (a thread may keep retrying to save, self spinning) ABA problem

    IV self spin, mutex
    1.self spin, keep trying to acquire lock --- no context switching ----user space
    2. thread yield and go to sleep, let OS to wake it up ---- context switching  ----kernal


OS如何调动锁：

    当线程A调用FuncA()，线程B也调用FUNCA(),OS如何设计锁能保证他们竞争的唯一性的呢？
    我们把具体过程来分析一下。假设线程A调用funcA()；它获取了锁，执行到中间某个代码的时候，时间片用完了，被OS调度出去，OS调度线程B来执行funcA(), 
    当线程B跑到lock(锁)，发现这个锁已经被线程A拿了，此时，线程B会主动把自己挂起到锁这个“事件”上(等着锁释放)。O
    S从新调度线程执行，当重新调度到线程A的时候，线程A执行，执行完成以后，释放掉这个锁，
    那么线程B又从等待这个锁的队列，到线程调度的就绪队列，
    又可被OS调度到，等线程A调度出去后，线程B去lock这个锁，就占用了这个锁，然后继续执行。这样就保证了lock/unlock之间的代码永远只有一个线程跑进去了。这样保护了这段代码里面相关的数据和逻辑。
    
    每个互斥锁都有自己的等待队列，但是锁的等待队列并不只有一个，至少有两个。也就是相当于将等待队列细分了。
    一条队列尚未获得锁的队列，当锁available的时候OS选取一个线程获得锁
    另一条队列是已经获得过锁，但是由于某些情况，调用了wait方法，所以导致等待的。等待无法被OS叫醒

    Waiting Queue, Ready Queue, once notified, move from waiting queue to ready queue



进程与线程的区别？

    每个进程(应用App)相当于一个容器，所有应用App里面需要的资源和机制都在进程里面。

    线程是OS独立调度执行的单元，OS调度执行的单位就是线程，线程需要以进程作为容器和使用进程相关的环境。
    每个线程共享进程的代码段内存空间，所以我们编写多线程代码的时候，可以在任何线程调用任何函数。
    每个线程共享进程的数据段内存空间，所以我们编写多线程代码的时候，可以在任何线程访问全局变量。
    每个线程共享进程的堆，所以我们编写多线程代码的时候，可以在一个线程访问另外一个线程new/malloc出来的内存对象。
    每个线程都有自己的栈的空间，所以可以独立调用执行函数（参数，局部变量，函数跳转）相互之间不受影响。

进程的五种状态：
    初始化
    可运行
    运行中
    阻塞
    销毁



线程上下文切换和进程上下文切换的区别

    进程切换分两步
    1.切换页目录以使用新的地址空间
    2.切换内核栈和硬件上下文。

    对于linux来说，线程和进程的最大区别就在于地址空间。
    对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。所以明显是进程切换代价大

    线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。
    这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。
    另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。
    简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。
    还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）
    或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。

协程：

    进程和线程通过OS用时间片来管理，抢占式轮作。因为要保证没有恶意进程、线程永远占据CPU时间
    协程则在用户态主动协作，主动放弃，主动获取

    协程不是被操作系统内核所管理，而完全是由程序所控制
    Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。
    协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：
    协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。

    上下文切换比线程少：
    协程切换比线程切换快主要有两点：（1）协程切换完全在用户空间进行，线程切换涉及特权模式切换，需要在内核空间完成；（2）协程切换相比线程切换做的事情更少。
    协程切换只涉及基本的CPU上下文切换 线程的切换涉及到用户空间和内核空间的切换，也就是特权模式切换，然后需要操作系统调度模块完成线程调度（taskstruct），
    而且除了和协程相同基本的 CPU 上下文，还有线程私有的栈和寄存器等


进程调度算法？

    先来先服务调度算法FCFS
    短作业（进程）优先调度算法SJF
    高响应比优先调度算法HRRN
    基于时间片的轮转调度算法RR
    多级反馈队列算法FB


    协作式多任务：多个进程独立运行，但每个进程都要发扬风格，不执行规模过大的计算；或者执行规模较大的计算时，每隔一段时间主动调用一下OS提供的特定API，
    让出控制权给其它进程。总之，人之初，性本善。每个人都替别人着想，世界就会很美好。那万一出个恶人、病人呢？世界崩塌了。抢夺式多任务：系统里跑的程序，
    有的是坏人写的，也有的会意外病倒。操作系统要监控所有进程，公平分配CPU时间片等资源给每个应用；如果一个应用用完了自己的份额，那么操作系统就要强制暂停它的执行，
    保存它的执行现场，把CPU安排给另一个进程——从而避免坏进程/病态进程影响系统的正常运行。



内存屏障，Volatile：

    Volatile 内存可见性，此变量每次读取都是内存，而不是CPU寄存器或者缓存

    内存屏障到底是什么？内存屏障什么都不是，它只是一个抽象概念，就像OOP。如果这样说你不理解，那你把他理解成一堵墙，这堵墙正面与反面的指令无法被CPU乱序执行及这堵墙正面与反面的读写操作需有序执行。

    CPU提供了三个汇编指令串行化运行读写指令达到实现保证读写有序性的目的：

    SFENCE：在该指令前的写操作必须在该指令后的写操作前完成

    LFENCE：在该指令前的读操作必须在该指令后的读操作前完成

    MFENCE：在该指令前的读写操作必须在该指令后的读写操作前完成

    线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存 A中。当线程A和线程B需要通信时，
    线程A首先会把自己本地内存中修改后的x值刷新到主内 存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，
    此时线程B的本地内存的x值也变为了1。 从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。
    JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。

    在每个volatile写操作的前面插入一个StoreStore屏障。在每个volatile写操作的后面插入一个StoreLoad屏障。在每个volatile读操作的后面插入一个LoadLoad屏障。
    在每个volatile读操作的后面插入一个LoadStore屏障。


用户态 内核态


    在用户模式下，所有内存访问经过MMU，从而对内存的访问受到了保护；在特权模式下，内存访问绕过MMU，直接访问物理内存，从而获得完整的权限。

    现代MMU通常使用虚拟地址空间的技术来解决这个问题，也就是你说的“用户空间”。在用户模式下，所有访问内存的地址实际上都是虚拟地址，
    它与实际的物理地址是对应不上的。这样，即便两个应用程序使用了相同的地址，它们也可以做到互不干扰，只需要通过技术手段让它们实际映射到不同的物理地址就行了


    CPU在触发中断时需要自动切换到操作系统状态（否则无法进行多任务切换）
    操作系统状态可以自由切换到应用程序状态；应用程序状态不能任意切换到操作系统状态，但也需要有触发进入操作系统代码并切换到操作系统状态的能力（否则无法调用操作系统功能）


    因为多个应用程序要独立加载，如果两个应用程序执意要使用同一个内存地址，那就会发生严重的问题，操作系统必须防止这种事情发生外部设备一般来说都是很傻的，
    它并不知道多任务的存在，不管谁操作外部设备它都是一样响应。这样如果多个应用程序自己直接去操纵硬件设备，就会出现相互冲突，
    有可能一个程序的数据被发送到了另一个程序等等操作系统必须自己响应硬件中断，通过硬件中断来切换任务上下文，让合适的任务在合适的时机继续执行。
    如果应用程序自己把中断响应程序改掉了，整个操作系统都会崩溃操作系统必须有能力在单个应用程序崩溃的情况下清理这个应用程序使用的资源，保证不影响其他应用程序；这就要求它必须清楚知道每个应用程序使用了哪些资源
